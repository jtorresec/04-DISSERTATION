---
title: "Examples with Dahlberg Data"
author: "Michael Sigmund, Robert Ferstl"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: panelvar_references.bib
vignette: >
  %\VignetteIndexEntry{Examples with Dahlberg Data} 
  %\VignetteEngine{knitr::rmarkdown_notangle} 
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Examples with Dahlberg Data

We apply our package to the Dahlberg data set which was used by @Dahlberg2000 and many other papers. The panel data set consists of 265 Swedish municipalities and covers 9 years (1979-1987). These variables include total expenditures (expenditures), total own-source revenues (revenues) and intergovernmental grants received by the municipality (grants). Following @Dahlberg2000 grants from the central to the local government are of three kinds: support to municipalities with small tax capacity, grants toward the running of certain local government activities and grants toward certain investments.

```{r ex1_cigar_data, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, eval = FALSE}
library(panelvar)
data("Dahlberg")
ex1_dahlberg_data <- pvargmm(dependent_vars = c("expenditures", "revenues", "grants"),
                                         lags = 1,
                                         transformation = "fod",
                                         data = Dahlberg,
                                         panel_identifier=c("id", "year"),
                                         steps = c("twostep"),
                                         system_instruments = FALSE,
                                         max_instr_dependent_vars = 99,
                                         max_instr_predet_vars = 99,
                                         min_instr_dependent_vars = 2L,
                                         min_instr_predet_vars = 1L,
                                         collapse = FALSE
)
summary(ex1_dahlberg_data)
```

```{r ex1_dahlberg_data_cache, message = FALSE, echo=FALSE}
library(panelvar)
data("ex1_dahlberg_data")
summary(ex1_dahlberg_data)
```


Given the definition of grants our results suggest that grants reduce both expenditures and revenues. Expenditures and grants both have a significant positive autocorrelation coefficient. Our results also suggest that revenues are positively influenced by previous expenditures.

Following @Roodman2009a a critical assumption for the validity of the GMM estimation is that the instruments are exogenous. If the model is overidentified, the Hansen J-Test @Hansen1982 can be applied. Overidentification means that there are more moment conditions than parameters to be estimated. 

For our example the number of moment conditions and the number of parameters can be calulated as follows:

```{r ex1_dahlberg_data_moment_conditions, message=FALSE, warning=FALSE}
nof_moment_conds <- nrow(ex1_dahlberg_data$instruments[[1]])
nof_parameters   <- ncol(ex1_dahlberg_data$second_step) * nrow(ex1_dahlberg_data$second_step)
print(nof_moment_conds-nof_parameters)
```

The test can be applied to onestep ($\mathbf{\Lambda}_{\mathbf{Z}}$) and twostep ($\mathbf{\Lambda}_{\mathbf{Z}_{\hat{e}}}$) GMM estimations:

$$
 \left ( \sum_{i=1}^{N} \mathbf{Z}_{i} \mathbf{\hat{E}_{i}} \right )^{\intercal}	 \mathbf{\Lambda}_{\mathbf{Z}_{\hat{e}}}^{-1} \left ( \sum_{i=1}^{N} \mathbf{Z}_{i} \mathbf{\hat{E}_{i}} \right ) \sim \tilde{\chi}^2_{L-K}
$$

L represents the number of instruments. K counts the number of parameters in the model. The null hypothesis of the test is that the instruments are exogenous.

```{r ex1_cigar_data_hansen, message=FALSE, warning=FALSE}
ex1_hansen_j_test <- hansen_j_test(ex1_dahlberg_data)
print(ex1_hansen_j_test)
```

The Hansen test states that the null hypothesis is not rejected. Closely related specification tests that are based on the Hansen statistics were introduced by @Andrews2001. Their tests (BIC, AIC and HQIC) can be used to choose among competing models, mainly to select the optimal lag length of the endogenous variables.

In the original notation of \citet{Andrews2001} the basic MMSC reads as follows:

$$
	MMSC_n(b,c) = J_n(b,c) - h(|c|-|b|) \kappa_n
$$

$J_n(b,c)$ is the Hansen J test statistics. b stands for the number of parameters, c is the number of moment conditions and n is the number of total observations. We implemented three different versions of MMSC function:

$$
\begin{aligned}

	MMSC_{BIC,n}(b, c) & = & J_n(b,c) - (|c|-|b|) \cdot ln(n) \\
    
    MMSC_{AIC,n}(b, c) & = & J_n(b,c) - (|c|-|b|) \cdot 2 \\
    
    MMSC_{HQIC,n}(b, c) & = & J_n(b,c) - Q \cdot (|c|-|b|) \cdot ln(ln(n)) 
    

\end{aligned}
$$

```{r ex1_cigar_data_Andrew_Lu, message=FALSE, warning=FALSE}
ex1_dahlberg_lag_selection <- Andrews_Lu_MMSC(ex1_dahlberg_data, HQ_criterion = 2.1)

print(ex1_dahlberg_lag_selection)
```

To see how these tests are used to select the best lag order, we estimate example 1 with lags = 2 (all other inputs are equal).


```{r ex2_dahlberg_data, message=FALSE, warning=FALSE, eval = FALSE}
ex2_dahlberg_data <- pvargmm(dependent_vars = c("expenditures", "revenues", "grants"),
                                         lags = 2,
                                         transformation = "fod",
                                         data = Dahlberg,
                                         panel_identifier=c("id", "year"),
                                         steps = c("twostep"),
                                         system_instruments = FALSE,
                                         max_instr_dependent_vars = 99,
                                         max_instr_predet_vars = 99,
                                         min_instr_dependent_vars = 2L,
                                         min_instr_predet_vars = 1L,
                                         collapse = FALSE
)
summary(ex2_dahlberg_data)
print(hansen_j_test(ex2_dahlberg_data))
print(Andrews_Lu_MMSC(ex2_dahlberg_data, HQ_criterion = 2.1))
```

```{r ex2_dahlberg_data_cache, echo=FALSE}
data("ex2_dahlberg_data")
summary(ex2_dahlberg_data)
print(hansen_j_test(ex2_dahlberg_data))
print(Andrews_Lu_MMSC(ex2_dahlberg_data, HQ_criterion = 2.1))
```

Since BIC, AIC and HQIC criteria of @Andrews2001 are relative performance measures where smaller is better, we would choose Lag = 1.

Next, we test the stability of the autoregressive process:


```{r stability_ex1_cigar_data_Andrew_Lu, fig.width=4, fig.height=4}
stab_ex1_dahlberg_data <- stability(ex1_dahlberg_data)
print(stab_ex1_dahlberg_data)
plot(stab_ex1_dahlberg_data)
```

In vector autoregression models researchers are often interested in impuls response analysis. Recently, researcher prefer the generalized impuls response analysis (GIRF) introduced by @Pesaran1998 to orthogonal impuls response analysis (OIRF) as it is independent of the ordering of the endogenous variables. However, GIRF and OIRF are closely related.
@Lin2006 states that when $\mathbf{\Sigma}_{\epsilon}$ is diagonal OIRF and GIRF are the same. The GIRF of the effect of an unit shock to the r-th equation is the same as that of an orthogonal impulse response but different for other shocks. Hence, the GIRF can easily computed by using OIRF with each variable as the leading one.


```{r girf_ex1_cigar_data_Andrew_Lu, fig.width=4, fig.height=4}

ex1_dahlberg_data_girf <-  girf(ex1_dahlberg_data, n.ahead = 8, ma_approx_steps= 8)
ex1_dahlberg_data_oirf <-  oirf(ex1_dahlberg_data, n.ahead = 8)
ex1_dahlberg_data_girf[[1]]
ex1_dahlberg_data_oirf[[1]]

```

Finally, we will use the bootstrap function of calculate confidence intervals.

```{r ex1_dahlberg_data_bootstrapping, message=FALSE, warning=FALSE, eval = FALSE}
ex1_dahlberg_data_bs <-  bootstrap_irf(ex1_dahlberg_data, typeof_irf = c("GIRF"),
                                       n.ahead = 8,
                                       nof_Nstar_draws = 500,
                                       confidence.band = 0.95)
```


```{r ex1_dahlberg_data_girfplot, message=FALSE, warning=FALSE, fig.width=7, fig.height=5}
data("ex1_dahlberg_data_bs")
plot(ex1_dahlberg_data_girf, ex1_dahlberg_data_bs)
```

For many researchers the estimated fixed effects (i.e. individual specific intercept) of each individual and equation might be of interest. We provide a similar function to  fixef() in the plm package.

```{r ex1_dahlberg_data_fixedef, message=FALSE, warning=FALSE, fig.width=7, fig.height=5}
ex1_dahlberg_data_fe <- fixedeffects(ex1_dahlberg_data, Only_Non_NA_rows = TRUE)
ex1_dahlberg_data_fe_table <- matrix(unlist(ex1_dahlberg_data_fe), byrow = TRUE,
                                     nrow=length(ex1_dahlberg_data_fe))
colnames(ex1_dahlberg_data_fe_table) <- ex1_dahlberg_data$dependent_vars
rownames(ex1_dahlberg_data_fe_table) <- unique(ex1_dahlberg_data$Set_Vars$category)
head(ex1_dahlberg_data_fe_table)
```





# References